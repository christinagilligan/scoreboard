<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scoreboard + Clock + Weather + Big Play</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1320;
      --panel: #121a2b;
      --text: #e9eefc;
      --muted: #9fb0d1;
      --accent: #3aa0ff;
      --up: #20c997;      /* green */
      --down: #ff6b6b;    /* red */
      --bar-bg: #0d1730;

      /* Team-theming (will be set dynamically) */
      --team: #20c997;
      --team-contrast: #031018;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { padding-bottom: 10px; } /* space for fixed stock bar */

    .layout { display: grid; grid-template-rows: auto 1fr; min-height: 100vh; }
    header {
      display: grid; grid-template-columns: 1fr auto 1fr; gap: 16px; align-items: center;
      padding: 12px 16px; background: linear-gradient(180deg, #0d1730 0%, #0b1320 100%);
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .brand { font-weight: 700; letter-spacing: .5px; color: var(--muted); }
    .clock { font-size: clamp(22px, 4vw, 40px); font-weight: 700; text-align: center; }
    .weather { display: flex; justify-content: flex-end; align-items: center; gap: 14px; color: var(--muted); font-size: clamp(12px, 1.8vw, 16px); white-space: nowrap; }
    .wx-temp { font-size: clamp(16px, 2.5vw, 22px); font-weight: 700; color: var(--text); }
    .wx-hi-lo { font-variant-numeric: tabular-nums; }
    .chip { padding: 6px 10px; border-radius: 999px; background: var(--panel); color: var(--text); border: 1px solid rgba(255,255,255,0.08); }

    main { padding: 10px; }
    .card {
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 18px;
      padding: 10px;
      height: calc(100vh - 110px - 62px);
      display: flex; flex-direction: column;
    }
    .scorestream-widget-container { width: 100%; flex: 1 1 auto; min-height: 240px; border-radius: 12px; overflow: hidden; }


    /* ===== BIG PLAY POPUP (obnoxious, TEAM-THEMED) ===== */
    #bigplay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.55); z-index: 99999; }
    #bigplay-card {
      max-width: 1000px; width: min(94vw, 1000px);
      background: #0b1320;
      border: 3px solid var(--team);
      border-radius: 20px;
      box-shadow:
        0 30px 120px rgba(0,0,0,.8),
        0 0 40px color-mix(in oklab, var(--team) 70%, transparent) inset;
      padding: 24px 26px; text-align: center; transform: translateY(-8px); opacity: 0;
      transition: transform .25s ease, opacity .25s ease, box-shadow .25s ease;
      animation: bp-flash 1s linear infinite, bp-shake 2.2s ease-in-out infinite;
    }
    #bigplay.show #bigplay-card { transform: translateY(0); opacity: 1; }
    #bigplay-logo { display:none; width:64px; height:64px; border-radius:12px; margin-bottom:10px; object-fit:contain; background:#111; }
    #bigplay-badge {
      display: inline-block; padding: 10px 16px; border-radius: 999px;
      background: var(--team); color: var(--team-contrast);
      font-weight: 900; letter-spacing:.8px; font-size: clamp(1rem, 2.2vw, 1.25rem); margin-bottom: 12px;
    }
    #bigplay-meta { color:#9fb0d1; font-size: clamp(1rem, 2.2vw, 1.35rem); margin-bottom: 8px; }
    #bigplay-text { color:#e9eefc; font-size: clamp(1.25rem, 3.2vw, 2rem); line-height: 1.35; font-weight: 800; text-shadow: 0 0 12px rgba(58,160,255,.5); margin-bottom: 6px; }
    @keyframes bp-flash { 0%,100%{ box-shadow:0 30px 120px rgba(0,0,0,.8), 0 0 20px color-mix(in oklab, var(--team) 45%, transparent) inset; border-color:var(--team) } 50%{ box-shadow:0 30px 120px rgba(0,0,0,.8), 0 0 60px color-mix(in oklab, var(--team) 75%, transparent) inset; }}
    @keyframes bp-shake { 0%,100%{ transform: translateY(0) } 20%{ transform: translateY(-2px) } 40%{ transform: translateY(1px) } 60%{ transform: translateY(-1px) } 80%{ transform: translateY(2px) } }
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <div class="brand">üèüÔ∏è Live Scores</div>
      <div class="clock" id="clock">--:--:--</div>
      <div class="weather">
        <span id="wx-location" class="chip">Locating‚Ä¶</span>
        <span class="wx-temp" id="wx-temp">--¬∞</span>
        <span id="wx-desc">‚Äî</span>
        <span class="wx-hi-lo" id="wx-hi-lo">H --¬∞ / L --¬∞</span>
      </div>
    </header>

    <main>
      <div class="card">
        <!-- Scorestream widget -->
        <div class="scorestream-widget-container"
             data-ss_widget_type="horzScoreboard"
             data-user-widget-id="66524">
        </div>
      </div>
    </main>
  </div>


  <!-- BIG PLAY POPUP -->
  <div id="bigplay" aria-live="assertive" style="display:none;">
    <div id="bigplay-card">
      <img id="bigplay-logo" alt="" />
      <div id="bigplay-badge">üî• BIG PLAY üî•</div>
      <div id="bigplay-meta"></div>
      <div id="bigplay-text"></div>
    </div>
  </div>

  <!-- Scorestream script -->
  <script src="https://scorestream.com/apiJsCdn/widgets/embed.js" async></script>

  <script>
    /* ========= CLOCK ========= */
    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent =
        now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }
    updateClock(); setInterval(updateClock, 1000);

    /* ========= WEATHER (Open-Meteo, Fahrenheit) ========= */
    const WX_FALLBACK = { name: 'Washington, DC', lat: 38.9072, lon: -77.0369 };
    async function getWeather(lat, lon, label) {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`
        + `&current=temperature_2m,weather_code`
        + `&hourly=temperature_2m`
        + `&daily=temperature_2m_max,temperature_2m_min,weather_code`
        + `&temperature_unit=fahrenheit`
        + `&timezone=auto`;
      const r = await fetch(url);
      const j = await r.json();
      const temp = Math.round(j.current?.temperature_2m ?? NaN);
      const wcode = j.current?.weather_code ?? j.daily?.weather_code?.[0];
      const hi = Math.round(j.daily?.temperature_2m_max?.[0] ?? NaN);
      const lo = Math.round(j.daily?.temperature_2m_min?.[0] ?? NaN);
      document.getElementById('wx-location').textContent = label;
      document.getElementById('wx-temp').textContent = `${isFinite(temp) ? temp : '--'}¬∞`;
      document.getElementById('wx-hi-lo').textContent = `H ${isFinite(hi) ? hi : '--'}¬∞ / L ${isFinite(lo) ? lo : '--'}¬∞`;
      document.getElementById('wx-desc').textContent = ({
        0:'Clear',1:'Mainly clear',2:'Partly cloudy',3:'Overcast',45:'Fog',48:'Freezing fog',
        51:'Drizzle',53:'Drizzle',55:'Drizzle',61:'Rain',63:'Rain',65:'Heavy rain',66:'Freezing rain',67:'Freezing rain',
        71:'Snow',73:'Snow',75:'Heavy snow',80:'Showers',81:'Showers',82:'Heavy showers',95:'Thunderstorm',96:'Thunder w/ hail',99:'Thunder w/ hail'
      })[wcode] || '‚Äî';
      setTimeout(() => getWeather(lat, lon, label), 10 * 60 * 1000);
    }
    (function initWeather(){
  // Hardcode: New York City
  const lat = 38.9586;
  const lon = -77.3570;
  const label = "Reston, VA";
  getWeather(lat, lon, label);
})();



    /* ========= BIG PLAY POPUP (USING NFL SCOREBOARD + SUMMARY) ========= */
    // Config
    const BIGPLAY = {
      hoursBack: 1,
      fixedDates: null,
      pollMs: 20_000,
      bigGainYards: 50,
      sound: false,
      vibrate: false,
      autoDismissMs: 10_000
    };

    // Big-play keywords
    const BIGPLAY_KEYWORDS = [
      // scoring
      'touchdown',' td ','td.','pick six','defensive touchdown',
      'two-point conversion','two point conversion',
      'field goal is good','field goal is no good',
      // turnovers
      'interception','intercepted','fumble','sack fumble','turnover on downs',
      // special teams
      'blocked punt','blocked kick','punt return','kickoff return','onside kick',
      // misc
      'safety'
    ];

    // Filters to skip noise
    const INCOMPLETE_RE = /\b(incomplete|incomp|falls incomplete|broken up|pass defended|passes? deflected)\b/i;
    const NO_PLAY_RE    = /\b(nullified|no play|offsetting penalties?)\b/i;

    // Robust yard parser
    function yardsFrom(text) {
      const t = text || '';
      let m = /\bfor\s+(\d+)\s*(yards?|yds?)\b/i.exec(t);
      if (m) return parseInt(m[1], 10);
      m = /\b(\d+)\s*[- ]?(yards?|yds?)\b/i.exec(t);
      return m ? parseInt(m[1], 10) : null;
    }

    // Deep *completed* pass heuristic (optional backup when yards absent)
    function isDeepCompletedPass(text) {
      const t = (text || '').toLowerCase();
      return /\bdeep (left|right|middle)\b/.test(t) && /\bcomplete(d)?\b/.test(t);
    }

    // Final big-play check
    function isBigPlay(play) {
      const t = (play.txt || '').toLowerCase();

      // üö´ Filter obvious non-plays / incompletions first
      if (INCOMPLETE_RE.test(t)) return false;
      if (NO_PLAY_RE.test(t)) return false;

      // ‚úÖ Keywords (TD, INT, fumble, etc.)
      if (BIGPLAY_KEYWORDS.some(k => t.includes(k))) return true;

      // ‚úÖ Yardage threshold (e.g., 30+)
      const y = yardsFrom(t);
      if ((y || 0) >= BIGPLAY.bigGainYards) return true;

      // ‚úÖ Deep completed pass heuristic
      if (isDeepCompletedPass(t)) return true;

      return false;
    }

    // ESPN endpoints
    const ESPN_SCOREBOARD = 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard';
    const ESPN_SUMMARY    = 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=';

    const seenPlays = new Set();
    let beepStopper = null;

    const elOverlay = document.getElementById('bigplay');
    const elMeta    = document.getElementById('bigplay-meta');
    const elText    = document.getElementById('bigplay-text');
    const elBadge   = document.getElementById('bigplay-badge');

    // Contrast calc for team text
    function contrastText(hex) {
      const h = (hex || '').replace('#','') || '20c997';
      const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
      const L = 0.299*r + 0.587*g + 0.114*b;
      return L > 140 ? '#031018' : '#e9eefc';
    }

    // Apply team theme + logo
    function applyTeamTheme(style) {
      const logoEl = document.getElementById('bigplay-logo');
      const color = style?.color ? ('#' + String(style.color).replace('#','')) : null;

      if (color) {
        document.documentElement.style.setProperty('--team', color);
        document.documentElement.style.setProperty('--team-contrast', contrastText(color));
      } else {
        document.documentElement.style.setProperty('--team', '#20c997');
        document.documentElement.style.setProperty('--team-contrast', '#031018');
      }

      if (style?.logo) {
        logoEl.src = style.logo;
        logoEl.style.display = 'block';
      } else {
        logoEl.removeAttribute('src');
        logoEl.style.display = 'none';
      }
    }

    // ===== NEW: robust team style maps =====
    function buildTeamStyleMaps(summaryJson) {
      const byId = {};
      const byAbbr = {};

      const put = (rec) => {
        if (!rec) return;
        const id = rec.id ? String(rec.id) : '';
        const abbr = (rec.abbr || '').toUpperCase();
        const color = (rec.color || '3aa0ff').replace('#','');
        const style = {
          id,
          abbr,
          nameShort: rec.nameShort || rec.nameFull || rec.displayName || abbr,
          nameFull:  rec.nameFull  || rec.nameShort || rec.displayName || abbr,
          color,
          logo: rec.logo || null
        };
        if (id)   byId[id] = style;
        if (abbr) byAbbr[abbr] = style;
      };

      // Source 1: header.competitions[0].competitors
      const comps = summaryJson?.header?.competitions?.[0]?.competitors || [];
      for (const c of comps) {
        const t = c?.team || {};
        put({
          id: t?.id || c?.id,
          abbr: t?.abbreviation,
          nameShort: t?.shortDisplayName || t?.displayName,
          nameFull: t?.displayName || t?.shortDisplayName,
          color: t?.color || c?.color,
          logo:
            (Array.isArray(t?.logos) && t.logos[0]?.href) ||
            t?.logo || t?.logos?.href || null
        });
      }

      // Source 2: boxscore.teams (optional)
      const bsTeams = summaryJson?.boxscore?.teams || [];
      for (const bt of bsTeams) {
        const t = bt?.team || bt;
        put({
          id: t?.id,
          abbr: t?.abbreviation,
          nameShort: t?.shortDisplayName || t?.displayName,
          nameFull: t?.displayName || t?.shortDisplayName,
          color: t?.color,
          logo:
            (Array.isArray(t?.logos) && t.logos[0]?.href) ||
            t?.logo || t?.logos?.href || null
        });
      }

      return { byId, byAbbr };
    }

    function resolveTeamStyle(rec, maps) {
      const { byId, byAbbr } = maps;
      const tryIds = [
        rec?.team?.id,
        rec?.start?.team?.id,
        rec?.end?.team?.id
      ].filter(Boolean).map(String);

      for (const id of tryIds) {
        if (byId[id]) return byId[id];
      }

      const rawAbbr =
        (rec?.team?.abbreviation ||
         rec?.team?.shortDisplayName ||
         rec?.start?.team?.abbreviation ||
         rec?.end?.team?.abbreviation ||
         '').toUpperCase();
      if (rawAbbr && byAbbr[rawAbbr]) return byAbbr[rawAbbr];

      if (rawAbbr) {
        return { id: '', abbr: rawAbbr, nameShort: rawAbbr, nameFull: rawAbbr, color: '3aa0ff', logo: null };
      }
      return null;
    }
    // ===== /NEW =====

    function showPopup(meta, text, teamStyle) {
      applyTeamTheme(teamStyle);

      // Prefer full name, then short, then abbr
      const name = teamStyle?.nameFull || teamStyle?.nameShort || teamStyle?.abbr || '';
      elBadge.textContent = name ? `${name} BIG PLAY` : 'üî• BIG PLAY üî•';

      elMeta.textContent = meta || '';
      elText.textContent = text || '';
      elOverlay.style.display = 'flex';
      requestAnimationFrame(() => elOverlay.classList.add('show'));
      if (BIGPLAY.sound) startBeepLoop();
      if (BIGPLAY.vibrate && 'vibrate' in navigator) navigator.vibrate([200,100,200,100,200]);
      if (Number.isFinite(BIGPLAY.autoDismissMs) && BIGPLAY.autoDismissMs > 0) setTimeout(hidePopup, BIGPLAY.autoDismissMs);
    }
    function hidePopup() {
      elOverlay.classList.remove('show');
      stopBeepLoop();
      setTimeout(() => { elOverlay.style.display = 'none'; }, 250);
    }
    function startBeepLoop() {
      stopBeepLoop();
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const makeBeep = (f, dur=0.18, type='square') => {
        const o = ac.createOscillator(); const g = ac.createGain();
        o.type = type; o.frequency.setValueAtTime(f, ac.currentTime);
        g.gain.setValueAtTime(0.001, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.08, ac.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + dur);
        o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime + dur + 0.02);
      };
      const cycle = () => { makeBeep(880); setTimeout(()=>makeBeep(660,0.18,'sawtooth'),220); setTimeout(()=>makeBeep(990,0.18,'square'),440); };
      cycle(); beepStopper = setInterval(cycle, 1200); window.__bpAudioCtx = ac;
    }
    function stopBeepLoop(){ if (beepStopper) clearInterval(beepStopper); beepStopper = null; }

    function datesParam() {
      if (BIGPLAY.fixedDates) return BIGPLAY.fixedDates;
      const end = new Date();
      const start = new Date(end.getTime() - BIGPLAY.hoursBack * 3600_000);
      const toYMD = d => d.getFullYear() + String(d.getMonth()+1).padStart(2,'0') + String(d.getDate()).padStart(2,'0');
      return `${toYMD(start)}-${toYMD(end)}`;
    }

    async function fetchJSON(url) {
      try {
        const r = await fetch(url, { cache: 'no-store' });
        if (r.ok) return r.json();
      } catch (_) {}
      const rp = await fetch(PROXY + encodeURIComponent(url), { cache: 'no-store' });
      if (!rp.ok) throw new Error('HTTP ' + rp.status);
      return rp.json();
    }

    // 1) Get NFL events for our window
    async function getEventIds() {
      const url = `${ESPN_SCOREBOARD}?limit=1000&dates=${encodeURIComponent(datesParam())}`;
      const j = await fetchJSON(url);
      const events = j?.events || [];
      return events.map(e => String(e?.id)).filter(Boolean);
    }

    // 2) For each event, fetch summary and yield plays with text + team style
    async function* getPlaysForEvents(eventIds) {
      for (const id of eventIds) {
        try {
          const j = await fetchJSON(ESPN_SUMMARY + encodeURIComponent(id));

          // Build team style maps once per event
          const maps = buildTeamStyleMaps(j);

          // A) Scoring plays
          for (const s of (j?.scoringPlays || [])) {
            const style = resolveTeamStyle(s, maps);
            const abbr  = (style?.abbr ||
                           s?.team?.abbreviation ||
                           s?.team?.shortDisplayName || '').toUpperCase();

            yield {
              id: `sc_${id}_${s.id ?? s.sequenceNumber ?? Math.random()}`,
              qtr: s?.period?.number ?? s?.period,
              clk: s?.clock?.displayValue ?? s?.clock,
              teamAbbr: abbr,
              teamStyle: style,
              txt: s?.text ?? s?.description ?? ''
            };
          }

          // B) Drive plays
          const driveBlocks = [j?.drives?.current, ...(j?.drives?.previous || [])].filter(Boolean);
          for (const block of driveBlocks) {
            for (const p of (block.plays || [])) {
              const style = resolveTeamStyle(p, maps);
              const abbr  = (style?.abbr ||
                             p?.team?.abbreviation ||
                             p?.team?.shortDisplayName || '').toUpperCase();

              yield {
                id: `pbp_${id}_${p.id ?? p.sequenceNumber ?? Math.random()}`,
                qtr: p?.period?.number ?? p?.period,
                clk: p?.clock?.displayValue ?? p?.clock,
                teamAbbr: abbr,
                teamStyle: style,
                txt: p?.text ?? p?.shortText ?? p?.type?.text ?? ''
              };
            }
          }

        } catch (e) {
          console.warn('[SUMMARY] failed for event', id, e);
        }
      }
    }

    async function pollPbp() {
      try {
        const eventIds = await getEventIds();
        console.log('[PBP] dates=', datesParam(), 'events=', eventIds.length);
        for await (const p of getPlaysForEvents(eventIds)) {
          if (!p.txt) continue;
          if (seenPlays.has(p.id)) continue;
          seenPlays.add(p.id);
          if (isBigPlay(p)) {
            const meta = [
              p.teamAbbr || '‚Ä¢',
              p.qtr ? `Q${p.qtr}` : null,
              p.clk || null
            ].filter(Boolean).join(' ¬∑ ');
            const head = (p.teamAbbr ? `[${p.teamAbbr}] ` : '') + p.txt;
            showPopup(meta, head, p.teamStyle);
          }
        }
      } catch (e) {
        console.warn('PBP poll failed:', e);
      } finally {
        setTimeout(pollPbp, BIGPLAY.pollMs);
      }
    }
    pollPbp();

    /* ========= MANUAL TEST HOOK ========= */
    window.bigPlayTest = function(meta = 'TEST ¬∑ Q1 ¬∑ 10:00', text = 'Fake 80-yard TD for testing!') {
      showPopup(meta, text, { color: 'ff6b6b', logo: '' });
    };
  </script>
</body>
</html>
